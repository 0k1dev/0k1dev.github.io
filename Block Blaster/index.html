<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Game Xếp Gạch 9x9</title>
<style>
  :root{
    --cell-size: 36px;
    --gap: 2px;
    --board-size: calc(var(--cell-size) * 9 + var(--gap) * 8);
  }
  body{
    font-family: system-ui, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: linear-gradient(180deg,#0f172a,#071132);
    color: #e6eef8;
    display:flex;
    gap:24px;
    padding:28px;
    align-items:flex-start;
    min-height:100vh;
  }
  .container{
    display:flex;
    gap:20px;
    align-items:flex-start;
  }
  .board {
    display:grid;
    grid-template-columns: repeat(9, var(--cell-size));
    grid-template-rows: repeat(9, var(--cell-size));
    gap: var(--gap);
    width: var(--board-size);
    height: var(--board-size);
    background:#071233;
    padding:8px;
    border-radius:8px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.6), inset 0 2px 0 rgba(255,255,255,0.02);
  }
  .cell {
    width:var(--cell-size);
    height:var(--cell-size);
    background: rgba(255,255,255,0.03);
    border-radius:4px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:700;
    color:transparent;
    cursor:pointer;
    transition: background .08s ease;
  }
  .cell.filled{
    background: linear-gradient(135deg,#60a5fa,#7c3aed);
    color:#fff;
    box-shadow: 0 2px 6px rgba(0,0,0,0.35);
  }
  .sidebar{
    width:340px;
    background: rgba(255,255,255,0.03);
    border-radius:12px;
    padding:16px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
  }
  h1{ margin:4px 0 10px 0; font-size:18px; }
  .pieces{
    display:flex;
    gap:12px;
    margin-top:8px;
    flex-wrap:wrap;
  }
  .piece {
    width:100px;
    min-height:100px;
    background: rgba(255,255,255,0.02);
    border-radius:8px;
    padding:8px;
    box-sizing:border-box;
    cursor:pointer;
    border:2px solid transparent;
  }
  .piece.selected{
    border-color: #facc15;
    box-shadow: 0 6px 20px rgba(250,204,21,0.12);
  }
  .mini-grid{
    display:grid;
    grid-template-columns: repeat(5, 1fr);
    grid-auto-rows: 1fr;
    gap:4px;
    width:100%;
    aspect-ratio:1/1;
  }
  .mini-cell{
    background: rgba(255,255,255,0.03);
    border-radius:3px;
    width:100%;
    height:100%;
  }
  .mini-cell.on{
    background: linear-gradient(135deg,#7dd3fc,#c084fc);
  }
  .info { margin-top:12px; font-size:14px; line-height:1.4; color:#dbeafe; }
  .btn{
    display:inline-block;
    padding:8px 12px;
    background:#0ea5e9;
    color:#021024;
    font-weight:700;
    border-radius:8px;
    margin-top:10px;
    cursor:pointer;
  }
  .score{ font-size:20px; font-weight:800; color:#bbf7d0; margin-top:6px; }
  .message{
    margin-top:12px;
    padding:10px;
    border-radius:8px;
    background: rgba(255,255,255,0.02);
    min-height:40px;
  }
  .small{ font-size:12px; color:#94a3b8; margin-top:6px;}
  footer{ position:fixed; left:12px; bottom:8px; font-size:12px; color:#93c5fd; }
</style>
</head>
<body>
  <div class="container">
    <div>
      <div class="board" id="board" role="grid" aria-label="Game board"></div>
      <div style="margin-top:12px;">
        <button class="btn" id="newGame">Bắt đầu lại</button>
        <span class="small" style="margin-left:12px;">Click chọn cục rồi click vào ô để đặt (ô là top-left của bounding box).</span>
      </div>
    </div>

    <div class="sidebar">
      <h1>Game Xếp Gạch 9×9</h1>
      <div><strong>Điểm:</strong> <span id="score" class="score">0</span></div>
      <div class="info">
        <div style="margin-top:8px;"><strong>3 cục hiện tại:</strong></div>
        <div class="pieces" id="pieces"></div>
      </div>
      <div class="message" id="message">Chơi thôi nào!</div>
      <div style="margin-top:10px;">
        <button class="btn" id="hintBtn">Kiểm tra chỗ đặt khả dĩ</button>
        <button class="btn" id="nextBtn" style="background:#10b981; margin-left:8px;">Lấy lượt mới (nếu đã đặt hết)</button>
      </div>
      <div class="small">Mỗi ô được xóa = 5 điểm.</div>
    </div>
  </div>

<footer>Simple block game — Made for you</footer>

<script>
(function(){
  // --- Config ---
  const ROWS = 9, COLS = 9;
  const POINT_PER_CELL = 5;

  // --- State ---
  const board = Array.from({length: ROWS}, ()=> Array(COLS).fill(0));
  let score = 0;
  let pieces = []; // mỗi piece = {id, shape:[[r,c]...], h, w}
  let selectedPieceIndex = -1;
  let gameOver = false;

  // --- DOM refs ---
  const boardEl = document.getElementById('board');
  const piecesEl = document.getElementById('pieces');
  const scoreEl = document.getElementById('score');
  const messageEl = document.getElementById('message');
  const newGameBtn = document.getElementById('newGame');
  const hintBtn = document.getElementById('hintBtn');
  const nextBtn = document.getElementById('nextBtn');

  // --- Helpers ---
  function buildGrid(){
    boardEl.innerHTML = '';
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = document.createElement('div');
        cell.className='cell';
        cell.dataset.r=r; cell.dataset.c=c;
        if(board[r][c]) cell.classList.add('filled');
        cell.addEventListener('click', ()=> onCellClick(r,c));
        boardEl.appendChild(cell);
      }
    }
  }

  function updateBoardUI(){
    const nodes = boardEl.children;
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const idx = r*COLS + c;
        const el = nodes[idx];
        if(board[r][c]) el.classList.add('filled'); else el.classList.remove('filled');
      }
    }
  }

  function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

  // generate shapes:
  // - some random shapes inside 3x3
  // - line shapes length 1..5 (horizontal or vertical)
  function generateRandomPiece(id){
    // decide line or blob
    if(Math.random() < 0.35){ // line
      const len = randInt(1,5);
      const dir = Math.random() < 0.5 ? 'h' : 'v';
      let coords = [];
      for(let i=0;i<len;i++){
        coords.push(dir==='h' ? [0,i] : [i,0]);
      }
      const h = dir==='h' ? 1 : len;
      const w = dir==='h' ? len : 1;
      return {id, shape: coords, h, w};
    } else {
      // random 3x3 blob: create a set of filled cells within 3x3 ensuring at least 1 cell and <=9
      const cells = [];
      // We'll produce a random pattern but ensure connectivity not required
      const used = [];
      for(let r=0;r<3;r++){
        for(let c=0;c<3;c++){
          if(Math.random() < 0.46) used.push([r,c]);
        }
      }
      if(used.length === 0) used.push([1,1]); // at least center
      // Trim bounding box
      const rs = used.map(x=>x[0]); const cs = used.map(x=>x[1]);
      const rmin = Math.min(...rs), rmax = Math.max(...rs);
      const cmin = Math.min(...cs), cmax = Math.max(...cs);
      const shape = used.map(([r,c]) => [r-rmin, c-cmin]);
      const h = rmax - rmin + 1;
      const w = cmax - cmin + 1;
      return {id, shape, h, w};
    }
  }

  function generateThreePieces(){
    pieces = [];
    for(let i=0;i<3;i++){
      pieces.push(generateRandomPiece(i));
    }
    selectedPieceIndex = -1;
    renderPieces();
  }

  function renderPieces(){
    piecesEl.innerHTML = '';
    pieces.forEach((p, idx) => {
      const box = document.createElement('div');
      box.className='piece' + (selectedPieceIndex===idx ? ' selected' : '');
      box.title = 'Click chọn cục này';
      box.addEventListener('click', ()=> {
        selectedPieceIndex = idx;
        renderPieces();
        messageEl.textContent = 'Đã chọn cục #' + (idx+1);
      });

      // Draw miniature 5x5 grid centered
      const grid = document.createElement('div');
      grid.className='mini-grid';
      // we place the shape in top-left of a 5x5 preview so user sees shape
      const preview = Array.from({length:25}, ()=> {
        const d = document.createElement('div');
        d.className='mini-cell';
        return d;
      });
      // offset to center shape roughly
      const offsetR = 1; const offsetC = 1;
      p.shape.forEach(([r,c])=>{
        const rr = r + offsetR, cc = c + offsetC;
        if(rr>=0 && rr<5 && cc>=0 && cc<5){
          const idx2 = rr*5 + cc;
          preview[idx2].classList.add('on');
        }
      });
      preview.forEach(n => grid.appendChild(n));
      box.appendChild(grid);

      // small info
      const info = document.createElement('div');
      info.style.fontSize='12px';
      info.style.marginTop='6px';
      info.textContent = `Kích: ${p.h}x${p.w}, ô: ${p.shape.length}`;
      box.appendChild(info);

      piecesEl.appendChild(box);
    });
  }

  // check if piece can be placed at (r,c) as top-left
  function canPlaceAt(p, r, c){
    if(r < 0 || c < 0) return false;
    if(r + p.h > ROWS || c + p.w > COLS) return false;
    for(const [dr,dc] of p.shape){
      const rr = r + dr, cc = c + dc;
      if(board[rr][cc]) return false;
    }
    return true;
  }

  // place piece at r,c (assume valid)
  function placeAt(p, r, c){
    for(const [dr,dc] of p.shape){
      const rr = r + dr, cc = c + dc;
      board[rr][cc] = 1;
    }
    updateBoardUI();
    // remove piece from pieces
    pieces = pieces.filter(px => px.id !== p.id);
    selectedPieceIndex = -1;
    renderPieces();
    // check clears
    const cleared = checkAndClearLines();
    if(cleared > 0){
      const gained = cleared * POINT_PER_CELL;
      score += gained;
      messageEl.textContent = `Đã xóa ${cleared} ô, +${gained} điểm!`;
    } else {
      messageEl.textContent = 'Đã đặt cục.';
    }
    scoreEl.textContent = score;
    // if all 3 pieces used, auto-generate next 3 unless game lost
    if(pieces.length === 0){
      generateThreePieces();
    }
    // after placement, check game over
    setTimeout(()=> {
      if(checkGameOver()){
        finishGame();
      }
    }, 10);
  }

  // check all full rows and columns, clear them, return number of cells cleared
  function checkAndClearLines(){
    const rowsFull = [];
    const colsFull = [];
    for(let r=0;r<ROWS;r++){
      if(board[r].every(x=>x===1)) rowsFull.push(r);
    }
    for(let c=0;c<COLS;c++){
      let full = true;
      for(let r=0;r<ROWS;r++){
        if(board[r][c] === 0){ full = false; break; }
      }
      if(full) colsFull.push(c);
    }
    // clear them
    let cleared=0;
    rowsFull.forEach(r=>{
      for(let c=0;c<COLS;c++){
        if(board[r][c] === 1){ board[r][c]=0; cleared++; }
      }
    });
    colsFull.forEach(c=>{
      for(let r=0;r<ROWS;r++){
        if(board[r][c] === 1){ board[r][c]=0; cleared++; }
      }
    });
    if(cleared>0) updateBoardUI();
    return cleared;
  }

  function onCellClick(r,c){
    if(gameOver) return;
    if(selectedPieceIndex === -1){
      messageEl.textContent = 'Chưa chọn cục. Click vào 1 trong 3 cục để chọn.';
      return;
    }
    const p = pieces[selectedPieceIndex];
    if(!p){
      messageEl.textContent = 'Cục đã bị dùng. Chọn lại.';
      selectedPieceIndex = -1;
      renderPieces();
      return;
    }
    if(canPlaceAt(p, r, c)){
      placeAt(p, r, c);
    } else {
      messageEl.textContent = 'Không thể đặt tại vị trí này.';
    }
  }

  function anyPlacementPossibleForPiece(p){
    for(let r=0;r<=ROWS-p.h;r++){
      for(let c=0;c<=COLS-p.w;c++){
        if(canPlaceAt(p, r, c)) return true;
      }
    }
    return false;
  }

  function checkGameOver(){
    // If any of the current pieces can be placed -> not over
    for(const p of pieces){
      if(anyPlacementPossibleForPiece(p)) return false;
    }
    // Else no piece placeable -> game over
    return true;
  }

  function finishGame(){
    gameOver = true;
    // final scoring rule
    if(score < 100000){
      messageEl.innerHTML = `KẾT THÚC — Điểm cuối: ${score}. <strong>mày ngu ko qua được 100000 điểm</strong>`;
    } else {
      const newScore = score + 1000;
      messageEl.innerHTML = `KẾT THÚC — Điểm trước khi cộng: ${score}. Cộng thêm 1000 => ${newScore}. <strong>mày ngu ko qua được A+1k điểm</strong>`;
      score = newScore;
      scoreEl.textContent = score;
    }
  }

  // hint: highlight any valid placements for selected piece
  function showHintsForSelected(){
    // simply highlight border of available cells
    // clear previous highlights by flashing message
    if(selectedPieceIndex === -1){
      messageEl.textContent = 'Chưa chọn cục để kiểm tra.';
      return;
    }
    const p = pieces[selectedPieceIndex];
    let count=0;
    for(let r=0;r<=ROWS-p.h;r++){
      for(let c=0;c<=COLS-p.w;c++){
        if(canPlaceAt(p,r,c)) count++;
      }
    }
    messageEl.textContent = `Có ${count} vị trí khả dĩ cho cục đã chọn.`;
  }

  // generate initial board and pieces
  function startNewGame(){
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) board[r][c]=0;
    score = 0; scoreEl.textContent = score;
    gameOver = false;
    messageEl.textContent = 'Bắt đầu mới — Chọn 1 trong 3 cục và click ô để đặt.';
    generateThreePieces();
    buildGrid();
    updateBoardUI();
  }

  // Next button: manually request new 3 pieces if current all used (or even if not)
  nextBtn.addEventListener('click', ()=> {
    if(gameOver) return;
    if(pieces.length === 0){
      generateThreePieces();
      messageEl.textContent = 'Lấy 3 cục mới.';
    } else {
      messageEl.textContent = 'Bạn vẫn còn ' + pieces.length + ' cục chưa dùng. Hãy đặt chúng trước.';
    }
  });

  // hint
  hintBtn.addEventListener('click', ()=> {
    showHintsForSelected();
  });

  newGameBtn.addEventListener('click', ()=>{
    startNewGame();
  });

  // Start
  startNewGame();

  // Optional: automatic check for game-over if none of 3 placeable initially
  // (occurs at beginning too if random pieces impossible)
  setTimeout(()=>{
    if(checkGameOver() && !gameOver){
      finishGame();
    }
  }, 50);

})();
</script>
</body>
</html>
