<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Block Puzzle 10x10 - HuyTKing</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ˜˜</text></svg>">
<style>
    body {
        background: #1d2333;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: Arial;
        color: #fff;
    }
    .game {
        display: flex;
        gap: 20px;
    }
    #board {
        width: 400px;
        height: 400px;
        background: #0a1020;
        display: grid;
        grid-template-columns: repeat(10, 1fr);
        grid-template-rows: repeat(10, 1fr);
        gap: 2px;
        padding: 5px;
        border-radius: 10px;
    }
    .cell {
        background: #141a2e;
        border-radius: 4px;
    }
    #pieces {
        width: 200px;
        display: flex;
        flex-direction: column;
        gap: 20px;
    }
    .piece {
        display: inline-grid;
        gap: 3px;
        padding: 10px;
        background: #0b1426;
        border-radius: 10px;
        cursor: grab;
        width: fit-content;
    }
    .block {
        width: 20px;
        height: 20px;
        background: #4fc3f7;
        border-radius: 4px;
    }
</style>
</head>
<body>

<div class="game">
    <div id="board"></div>
    <div id="pieces"></div>
</div>

<script>
const boardSize = 10;
const board = [];
const boardDiv = document.getElementById("board");
const piecesDiv = document.getElementById("pieces");

const blockShapes = [
    [[1]],
    [[1,1]],
    [[1],[1]],
    [[1,1,1]],
    [[1],[1],[1]],
    [[1,1],[1,1]],
    [[1,1,1],[0,1,0]]
];

// Táº¡o báº£ng
function initBoard() {
    for (let r = 0; r < boardSize; r++) {
        board[r] = [];
        for (let c = 0; c < boardSize; c++) {
            board[r][c] = 0;
            const cell = document.createElement("div");
            cell.className = "cell";
            cell.dataset.row = r;
            cell.dataset.col = c;
            boardDiv.appendChild(cell);
        }
    }
}
initBoard();

function renderBoard() {
    boardDiv.childNodes.forEach(cell => {
        let r = cell.dataset.row;
        let c = cell.dataset.col;
        cell.style.background = board[r][c] ? "#4fc3f7" : "#141a2e";
    });
}

function generatePieces() {
    piecesDiv.innerHTML = "";
    for (let i = 0; i < 3; i++) {
        let shape = blockShapes[Math.floor(Math.random() * blockShapes.length)];
        createPiece(shape);
    }
}

function createPiece(shape) {
    const piece = document.createElement("div");
    piece.className = "piece";
    piece.style.gridTemplateColumns = `repeat(${shape[0].length}, 20px)`;

    shape.forEach(row => {
        row.forEach(val => {
            const block = document.createElement("div");
            block.className = "block";
            block.style.visibility = val ? "visible" : "hidden";
            piece.appendChild(block);
        });
    });

    piece.draggable = true;

    // dragstart â€” lÆ°u shape vÃ o data
    piece.addEventListener("dragstart", e => {
        e.dataTransfer.setData("shape", JSON.stringify(shape));
        e.dataTransfer.setData("pieceID", piece.dataset.id);
        window._currentDraggingPiece = piece; // trÃ¡nh láº¥y nháº§m target
    });

    piecesDiv.appendChild(piece);
}

function canPlace(shape, row, col) {
    for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[0].length; c++) {
            if (shape[r][c]) {
                if (row + r >= boardSize || col + c >= boardSize) return false;
                if (board[row + r][col + c] !== 0) return false;
            }
        }
    }
    return true;
}

function place(shape, row, col) {
    for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[0].length; c++) {
            if (shape[r][c]) board[row + r][col + c] = 1;
        }
    }
    clearLines();
    renderBoard();
}

function clearLines() {
    // Clear hÃ ng
    for (let r = 0; r < boardSize; r++) {
        if (board[r].every(v => v === 1)) {
            for (let c = 0; c < boardSize; c++) board[r][c] = 0;
        }
    }
    // Clear cá»™t
    for (let c = 0; c < boardSize; c++) {
        let full = true;
        for (let r = 0; r < boardSize; r++) {
            if (!board[r][c]) full = false;
        }
        if (full) {
            for (let r = 0; r < boardSize; r++) board[r][c] = 0;
        }
    }
}

// Fix drag & drop lá»‡ch
boardDiv.addEventListener("dragover", e => e.preventDefault());

boardDiv.addEventListener("drop", e => {
    let shape = JSON.parse(e.dataTransfer.getData("shape"));
    let piece = window._currentDraggingPiece;
    if (!piece) return;

    let rect = boardDiv.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;

    // láº¥y kÃ­ch thÆ°á»›c Ã´ thá»±c trong DOM
    let cellSize = boardDiv.clientWidth / 10;

    let col = Math.floor(x / cellSize);
    let row = Math.floor(y / cellSize);

    if (canPlace(shape, row, col)) {
        place(shape, row, col);
        piece.remove();

        if (piecesDiv.children.length === 0) generatePieces();
    }
});

// Start game
generatePieces();
renderBoard();

</script>

</body>
</html>
