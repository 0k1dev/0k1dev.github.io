<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Carom 3 BƒÉng Pro 2P | Bi-a Chuy√™n Nghi·ªáp</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://img.icons8.com/color/48/000000/pool.png" type="image/x-icon">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(to bottom, #0a1f0a, #1a3a1a);
            color: #f0f0f0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .container {
            max-width: 1100px;
            width: 100%;
            text-align: center;
            margin: 0 auto;
            padding: 0 15px;
        }
        header { margin-bottom: 25px; }
        h1 {
            color: #00e5ff;
            text-shadow: 0 0 10px rgba(0, 229, 255, 0.7);
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00e5ff, #ffcc00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle {
            color: #ccc;
            font-size: 1.1rem;
            margin-bottom: 20px;
        }
        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 25px;
        }
        .table-outer {
            position: relative;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.8);
            overflow: hidden;
            border: 8px solid #3b2a1f;
        }
        canvas {
            display: block;
            background: #0e520e;
            cursor: crosshair;
        }
        .power-ui {
            position: absolute;
            left: -50px;
            top: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 45px;
        }
        .power-label {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            color: #ffcc00;
            font-weight: bold;
            font-size: 1.1rem;
            letter-spacing: 2px;
            margin-bottom: 15px;
        }
        .power-bar-container {
            width: 100%;
            height: 380px;
            background: #222;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: inset 0 0 10px #000;
            position: relative;
            border: 3px solid #444;
        }
        #powerBar {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 0%;
            background: linear-gradient(to top, #0f0 0%, #ff0 50%, #f00 100%);
            border-radius: 9px;
            transition: height 0.05s linear;
        }
        .power-value {
            margin-top: 10px;
            font-size: 1rem;
            color: #00e5ff;
            font-weight: bold;
            min-width: 45px;
            padding: 3px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }
        .spin-controls {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 10px;
            width: 100%;
        }
        .spin-label {
            color: #ff9966;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .spin-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .spin-btn {
            background: #333;
            color: #fff;
            border: 2px solid #666;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            min-width: 60px;
            transition: all 0.2s;
        }
        .spin-btn:hover {
            background: #444;
            border-color: #00e5ff;
        }
        .spin-btn.active {
            background: #00aacc;
            border-color: #00e5ff;
            color: #fff;
        }
        .player-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 900px;
            margin: 25px auto 15px;
            background: rgba(30, 60, 30, 0.7);
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }
        .player {
            text-align: center;
            flex: 1;
        }
        .player.active {
            background: rgba(0, 100, 100, 0.4);
            border-radius: 10px;
            padding: 10px;
            border: 2px solid #00e5ff;
        }
        .player-name {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .player1 .player-name { color: #00e5ff; }
        .player2 .player-name { color: #ffcc00; }
        .player-score {
            font-size: 3rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 8px currentColor;
        }
        .player-status {
            font-size: 1.2rem;
            margin-top: 8px;
            min-height: 1.8em;
            color: #a0e0a0;
        }
        .controls-instruction {
            background: rgba(40, 40, 40, 0.8);
            padding: 15px 25px;
            border-radius: 15px;
            margin: 15px auto 30px;
            max-width: 900px;
            line-height: 1.8;
            text-align: left;
            font-size: 1.05rem;
        }
        .controls-instruction h3 {
            color: #ffcc00;
            margin-bottom: 10px;
            text-align: center;
        }
        kbd {
            background: #333;
            padding: 4px 10px;
            border-radius: 6px;
            font-family: monospace;
            border: 1px solid #666;
            box-shadow: 0 2px 0 #222;
            color: #ffcc00;
        }
        footer {
            margin-top: 20px;
            color: #aaa;
            font-size: 0.9rem;
            text-align: center;
            padding: 15px;
            border-top: 1px solid #333;
            width: 100%;
        }
        .rule-highlight {
            color: #ff9966;
            font-weight: bold;
        }
        .cue-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #a0e0a0;
        }
        @media (max-width: 1000px) {
            .game-area { flex-direction: column; }
            .power-ui {
                position: static;
                flex-direction: row;
                width: auto;
                height: auto;
                margin-top: 20px;
                justify-content: center;
            }
            .power-label { writing-mode: horizontal-tb; transform: none; margin: 0 15px 0 0; }
            .power-bar-container { width: 40px; height: 200px; }
            .player-info { flex-direction: column; align-items: center; }
            .player { margin-bottom: 15px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üé± CAROM 3 BƒÇNG CHUY√äN NGHI·ªÜP</h1>
            <p class="subtitle">ƒê·∫•u tr√≠ 2 ng∆∞·ªùi ch∆°i - C√≥ √°p ph√™ - V·∫≠t l√Ω ch√¢n th·ª±c</p>
        </header>

        <div class="game-area">
            <div class="table-outer">
                <div class="power-ui">
                    <div class="power-label">L·ª∞C ƒê·∫®Y</div>
                    <div class="power-bar-container">
                        <div id="powerBar"></div>
                    </div>
                    <div class="power-value" id="powerValue">0%</div>
                    <div class="spin-controls">
                        <div class="spin-label">√ÅP PH√ä:</div>
                        <div class="spin-buttons">
                            <button class="spin-btn" data-spin="none" id="spinNone">Kh√¥ng</button>
                            <button class="spin-btn" data-spin="top" id="spinTop">Tr√™n</button>
                            <button class="spin-btn" data-spin="bottom" id="spinBottom">D∆∞·ªõi</button>
                            <button class="spin-btn" data-spin="left" id="spinLeft">Tr√°i</button>
                            <button class="spin-btn" data-spin="right" id="spinRight">Ph·∫£i</button>
                        </div>
                    </div>
                </div>
                <canvas id="gameCanvas" width="900" height="450"></canvas>
                <div class="cue-info" id="cueInfo">Nh·∫•p v√†o bi c√°i ƒë·ªÉ k√©o c∆°</div>
            </div>

            <div class="player-info">
                <div class="player player1" id="player1Info">
                    <div class="player-name">NG∆Ø·ªúI CH∆†I 1</div>
                    <div class="player-score" id="score1">0</div>
                    <div class="player-status" id="status1">üîµ ƒêang ch·ªù...</div>
                </div>
                <div class="player player2" id="player2Info">
                    <div class="player-name">NG∆Ø·ªúI CH∆†I 2</div>
                    <div class="player-score" id="score2">0</div>
                    <div class="player-status" id="status2">üü° S·∫µn s√†ng</div>
                </div>
            </div>
        </div>

        <div class="controls-instruction">
            <h3>üéÆ H∆Ø·ªöNG D·∫™N ƒêI·ªÄU KHI·ªÇN & LU·∫¨T CH∆†I</h3>
            <p><strong>C√°ch ch∆°i:</strong> M·ª•c ti√™u l√† d√πng bi c√°i (tr·∫Øng) ch·∫°m <span class="rule-highlight">c·∫£ hai bi m·ª•c ti√™u (ƒë·ªè v√† v√†ng)</span> sau khi bi c√°i ƒë√£ n·∫©y <span class="rule-highlight">√≠t nh·∫•t 3 bƒÉng</span>. M·ªói c√∫ ƒë√°nh h·ª£p l·ªá ƒë∆∞·ª£c <span class="rule-highlight">1 ƒëi·ªÉm</span>.</p>
            <p><strong>ƒêi·ªÅu khi·ªÉn:</strong></p>
            <ul>
                <li><kbd>CLICK CHU·ªòT</kbd> v√†o bi c√°i ƒë·ªÉ hi·ªán c√¢y c∆°.</li>
                <li><kbd>K√âO CHU·ªòT</kbd> ra xa bi c√°i ƒë·ªÉ l·∫•y l·ª±c (c√†ng xa l·ª±c c√†ng m·∫°nh).</li>
                <li><kbd>TH·∫¢ CHU·ªòT</kbd> ƒë·ªÉ th·ª±c hi·ªán c√∫ ƒë√°nh.</li>
                <li>Ch·ªçn <kbd>√ÅP PH√ä</kbd> (spin) ƒë·ªÉ ƒëi·ªÅu khi·ªÉn ƒë∆∞·ªùng ƒëi c·ªßa bi.</li>
                <li>Ch·ªù t·∫•t c·∫£ bi d·ª´ng h·∫≥n ƒë·ªÉ k·∫øt th√∫c l∆∞·ª£t v√† t√≠nh ƒëi·ªÉm.</li>
            </ul>
            <p><strong>√Åp ph√™ (spin):</strong> Tr√™n (bi l√πi), D∆∞·ªõi (bi ti·∫øn), Tr√°i/Ph·∫£i (ƒë·ªïi h∆∞·ªõng sau ch·∫°m bƒÉng).</p>
        </div>

        <footer>
            <p>¬© 2025 Carom 3 BƒÉng Pro - Phi√™n b·∫£n c√≥ √°p ph√™ | M√¥n th·ªÉ thao tr√≠ tu·ªá v√† k·ªπ thu·∫≠t</p>
        </footer>
    </div>

    <script>
        // ==================== C·∫§U H√åNH GAME ====================
        const CONFIG = {
            BALL_RADIUS: 10,
            FRICTION: 0.990,
            MAX_POWER: 150,
            MIN_MOVING_SPEED: 0.04,
            TIME_SCALE_SLOWMO: 0.3,
            SLOWMO_DURATION: 150,
            SPIN_STRENGTH: 0.8, // C∆∞·ªùng ƒë·ªô √°p ph√™
            CUE_MIN_LENGTH: 30,
            CUE_MAX_LENGTH: 200
        };

        // ==================== THAM CHI·∫æU DOM ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const powerBar = document.getElementById('powerBar');
        const powerValue = document.getElementById('powerValue');
        const score1El = document.getElementById('score1');
        const score2El = document.getElementById('score2');
        const status1El = document.getElementById('status1');
        const status2El = document.getElementById('status2');
        const player1Info = document.getElementById('player1Info');
        const player2Info = document.getElementById('player2Info');
        const cueInfo = document.getElementById('cueInfo');
        const spinButtons = document.querySelectorAll('.spin-btn');

        // ==================== L·ªöP BI ====================
        class Ball {
            constructor(x, y, color, type) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.spinX = 0;  // √Åp ph√™ ngang
                this.spinY = 0;  // √Åp ph√™ d·ªçc
                this.color = color;
                this.type = type;
                this.hitWallX = false;
                this.hitWallY = false;
            }
            moving() {
                return Math.hypot(this.vx, this.vy) > CONFIG.MIN_MOVING_SPEED;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, CONFIG.BALL_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // V·∫Ω ƒëi·ªÉm ƒë√°nh n·∫øu c√≥ √°p ph√™
                if (this.type === 'cue' && (this.spinX !== 0 || this.spinY !== 0)) {
                    ctx.beginPath();
                    let spinX = this.spinX * CONFIG.BALL_RADIUS * 0.7;
                    let spinY = this.spinY * CONFIG.BALL_RADIUS * 0.7;
                    ctx.arc(this.x + spinX, this.y + spinY, 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff0000';
                    ctx.fill();
                }
                
                // Vi·ªÅn cho bi c√°i
                if (this.type === 'cue') {
                    ctx.strokeStyle = '#aaa';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
                
                // Ch·∫•m ƒëen cho bi m·ª•c ti√™u
                if (this.type === 'red' || this.type === 'yellow') {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, CONFIG.BALL_RADIUS * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = '#000';
                    ctx.fill();
                }
            }
            
            applySpin() {
                // √Åp d·ª•ng √°p ph√™ v√†o v·∫≠n t·ªëc
                this.vx += this.spinX * CONFIG.SPIN_STRENGTH;
                this.vy += this.spinY * CONFIG.SPIN_STRENGTH;
                
                // Reset √°p ph√™ sau khi √°p d·ª•ng
                this.spinX = 0;
                this.spinY = 0;
            }
        }

        // T·∫°o bi
        const white = new Ball(150, 225, '#f8f8f8', 'cue');
        const red = new Ball(450, 160, '#ff4d4d', 'red');
        const yellow = new Ball(600, 290, '#ffff66', 'yellow');
        const balls = [white, red, yellow];

        // ==================== TR·∫†NG TH√ÅI GAME ====================
        let gameState = {
            currentPlayer: 1,
            scores: [0, 0],
            cushionHits: 0,
            hitRed: false,
            hitYellow: false,
            shotInProgress: false,
            cueActive: false,           // C√¢y c∆° ƒëang ho·∫°t ƒë·ªông
            cueDragging: false,         // ƒêang k√©o c∆°
            cueStartX: 0,               // V·ªã tr√≠ b·∫Øt ƒë·∫ßu k√©o c∆° (tr√™n bi)
            cueStartY: 0,
            cueEndX: 0,                 // V·ªã tr√≠ k√©o ƒë·∫øn
            cueEndY: 0,
            power: 0,
            spinType: 'none',           // Lo·∫°i √°p ph√™
            replay: [],
            replaying: false,
            replayIndex: 0,
            timeScale: 1
        };

        // ==================== V·∫º & HI·ªÜU ·ª®NG ====================
        function drawBackground() {
            // V·∫Ω b√†n
            ctx.fillStyle = '#0e520e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // V·∫Ω logo ·ªü gi·ªØa b√†n
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const logoRadius = 40;
            ctx.beginPath();
            ctx.arc(centerX, centerY, logoRadius, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(centerX, centerY, 5, centerX, centerY, logoRadius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 100, 0, 0.4)');
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('HTK', centerX, centerY);

            // V·∫Ω vi·ªÅn b√†n
            ctx.strokeStyle = '#5b2c06';
            ctx.lineWidth = 18;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 6;
            ctx.strokeRect(9, 9, canvas.width - 18, canvas.height - 18);
        }

        function drawCue() {
            if (!gameState.cueActive) return;
            
            const dx = gameState.cueEndX - gameState.cueStartX;
            const dy = gameState.cueEndY - gameState.cueStartY;
            const distance = Math.hypot(dx, dy);
            const angle = Math.atan2(dy, dx);
            
            // T√≠nh l·ª±c d·ª±a tr√™n kho·∫£ng c√°ch k√©o
            const maxDrag = 150;
            const powerRatio = Math.min(distance / maxDrag, 1);
            gameState.power = powerRatio * CONFIG.MAX_POWER;
            
            // C·∫≠p nh·∫≠t thanh l·ª±c
            const percent = Math.round(gameState.power);
            powerBar.style.height = (gameState.power / CONFIG.MAX_POWER * 100) + '%';
            powerValue.textContent = percent + '%';
            powerValue.style.color = percent < 50 ? '#0f0' : percent < 80 ? '#ff0' : '#f00';
            
            // V·∫Ω ƒë∆∞·ªùng ng·∫Øm (ƒë∆∞·ªùng ch·∫•m)
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(gameState.cueStartX, gameState.cueStartY);
            ctx.lineTo(gameState.cueStartX + dx * 2, gameState.cueStartY + dy * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // V·∫Ω c√¢y c∆°
            ctx.translate(gameState.cueStartX, gameState.cueStartY);
            ctx.rotate(angle);
            
            // Th√¢n c∆° (k√©o ra ph√≠a sau)
            const cueLength = Math.max(CONFIG.CUE_MIN_LENGTH, Math.min(distance, CONFIG.CUE_MAX_LENGTH));
            ctx.fillStyle = '#deb887';
            ctx.fillRect(-cueLength, -3, cueLength + 20, 6);
            
            // ƒê·∫ßu c∆°
            ctx.fillStyle = '#d2691e';
            ctx.fillRect(-cueLength - 5, -2, 5, 4);
            
            // Vi·ªÅn c∆°
            ctx.strokeStyle = '#8b5a2b';
            ctx.lineWidth = 1;
            ctx.strokeRect(-cueLength, -3, cueLength + 20, 6);
            
            // V·∫Ω ƒëi·ªÉm ƒë√°nh tr√™n bi
            if (gameState.spinType !== 'none') {
                let spinX = 0, spinY = 0;
                switch(gameState.spinType) {
                    case 'top': spinY = -CONFIG.BALL_RADIUS * 0.7; break;
                    case 'bottom': spinY = CONFIG.BALL_RADIUS * 0.7; break;
                    case 'left': spinX = -CONFIG.BALL_RADIUS * 0.7; break;
                    case 'right': spinX = CONFIG.BALL_RADIUS * 0.7; break;
                }
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(spinX, spinY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
            
            // Hi·ªÉn th·ªã th√¥ng tin l·ª±c v√† √°p ph√™
            cueInfo.textContent = `L·ª±c: ${percent}% | √Åp ph√™: ${getSpinName(gameState.spinType)} | Th·∫£ chu·ªôt ƒë·ªÉ ƒë√°nh`;
        }

        function getSpinName(spinType) {
            switch(spinType) {
                case 'none': return 'Kh√¥ng';
                case 'top': return 'Tr√™n';
                case 'bottom': return 'D∆∞·ªõi';
                case 'left': return 'Tr√°i';
                case 'right': return 'Ph·∫£i';
                default: return 'Kh√¥ng';
            }
        }

        // ==================== VA CH·∫†M & V·∫¨T L√ù ====================
        function handleCollision(ballA, ballB) {
            const dx = ballB.x - ballA.x;
            const dy = ballB.y - ballA.y;
            const distance = Math.hypot(dx, dy);
            if (distance >= CONFIG.BALL_RADIUS * 2 || distance === 0) return;

            if (Math.hypot(ballA.vx, ballA.vy) > 2 || Math.hypot(ballB.vx, ballB.vy) > 2) {
                gameState.timeScale = CONFIG.TIME_SCALE_SLOWMO;
                setTimeout(() => { gameState.timeScale = 1; }, CONFIG.SLOWMO_DURATION);
            }

            const nx = dx / distance;
            const ny = dy / distance;
            const tx = -ny;
            const ty = nx;
            const dpTanA = ballA.vx * tx + ballA.vy * ty;
            const dpTanB = ballB.vx * tx + ballB.vy * ty;
            const dpNormA = ballA.vx * nx + ballA.vy * ny;
            const dpNormB = ballB.vx * nx + ballB.vy * ny;

            const m1 = (dpNormA * 1 + dpNormB * 2) / 3;
            const m2 = (dpNormA * 2 + dpNormB * 1) / 3;

            ballA.vx = tx * dpTanA + nx * m2 * 0.98;
            ballA.vy = ty * dpTanA + ny * m2 * 0.98;
            ballB.vx = tx * dpTanB + nx * m1 * 0.98;
            ballB.vy = ty * dpTanB + ny * m1 * 0.98;

            if (ballA === white || ballB === white) {
                if (ballA === red || ballB === red) gameState.hitRed = true;
                if (ballA === yellow || ballB === yellow) gameState.hitYellow = true;
            }
            
            // √Åp d·ª•ng hi·ªáu ·ª©ng √°p ph√™ khi ch·∫°m bƒÉng
            if (ballA === white) {
                ballA.vx += ballA.spinX * 0.5;
                ballA.vy += ballA.spinY * 0.5;
            }
        }

        function updatePhysics() {
            balls.forEach(ball => {
                ball.x += ball.vx * gameState.timeScale;
                ball.y += ball.vy * gameState.timeScale;
                ball.vx *= CONFIG.FRICTION;
                ball.vy *= CONFIG.FRICTION;

                // Va ch·∫°m v·ªõi bƒÉng v√† √°p d·ª•ng √°p ph√™
                if (ball.x < CONFIG.BALL_RADIUS && !ball.hitWallX) {
                    ball.vx = Math.abs(ball.vx) * 0.95;
                    // √Åp ph√™ tr√°i/ph·∫£i ·∫£nh h∆∞·ªüng ƒë·∫øn bƒÉng
                    if (ball.spinX !== 0) {
                        ball.vy += ball.spinX * 0.3;
                    }
                    ball.hitWallX = true;
                    if (ball === white) gameState.cushionHits++;
                }
                if (ball.x > canvas.width - CONFIG.BALL_RADIUS && !ball.hitWallX) {
                    ball.vx = -Math.abs(ball.vx) * 0.95;
                    if (ball.spinX !== 0) {
                        ball.vy += ball.spinX * 0.3;
                    }
                    ball.hitWallX = true;
                    if (ball === white) gameState.cushionHits++;
                }
                if (ball.y < CONFIG.BALL_RADIUS && !ball.hitWallY) {
                    ball.vy = Math.abs(ball.vy) * 0.95;
                    if (ball.spinY !== 0) {
                        ball.vx += ball.spinY * 0.3;
                    }
                    ball.hitWallY = true;
                    if (ball === white) gameState.cushionHits++;
                }
                if (ball.y > canvas.height - CONFIG.BALL_RADIUS && !ball.hitWallY) {
                    ball.vy = -Math.abs(ball.vy) * 0.95;
                    if (ball.spinY !== 0) {
                        ball.vx += ball.spinY * 0.3;
                    }
                    ball.hitWallY = true;
                    if (ball === white) gameState.cushionHits++;
                }

                if (ball.x > CONFIG.BALL_RADIUS && ball.x < canvas.width - CONFIG.BALL_RADIUS) ball.hitWallX = false;
                if (ball.y > CONFIG.BALL_RADIUS && ball.y < canvas.height - CONFIG.BALL_RADIUS) ball.hitWallY = false;
            });

            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    handleCollision(balls[i], balls[j]);
                }
            }
        }

        // ==================== LOGIC GAME ====================
        function startNewShot() {
            const dx = gameState.cueEndX - gameState.cueStartX;
            const dy = gameState.cueEndY - gameState.cueStartY;
            const distance = Math.hypot(dx, dy) || 1;
            
            // T√≠nh l·ª±c d·ª±a tr√™n kho·∫£ng c√°ch k√©o
            const powerFactor = gameState.power * 0.25;
            
            // ƒê·∫∑t v·∫≠n t·ªëc ban ƒë·∫ßu
            white.vx = (-dx / distance) * powerFactor;
            white.vy = (-dy / distance) * powerFactor;
            
            // √Åp d·ª•ng √°p ph√™
            switch(gameState.spinType) {
                case 'top':
                    white.spinY = -CONFIG.SPIN_STRENGTH;
                    white.vy *= 0.7; // Gi·∫£m l·ª±c ti·∫øn khi ƒë√°nh tr√™n
                    break;
                case 'bottom':
                    white.spinY = CONFIG.SPIN_STRENGTH;
                    white.vy *= 1.3; // TƒÉng l·ª±c ti·∫øn khi ƒë√°nh d∆∞·ªõi
                    break;
                case 'left':
                    white.spinX = -CONFIG.SPIN_STRENGTH;
                    break;
                case 'right':
                    white.spinX = CONFIG.SPIN_STRENGTH;
                    break;
            }
            
            // √Åp d·ª•ng √°p ph√™ v√†o bi
            white.applySpin();
            
            // Reset tr·∫°ng th√°i
            gameState.power = 0;
            gameState.cueActive = false;
            gameState.cueDragging = false;
            gameState.shotInProgress = true;
            gameState.replay = [];
            gameState.cushionHits = 0;
            gameState.hitRed = false;
            gameState.hitYellow = false;
            
            // Reset thanh l·ª±c
            powerBar.style.height = '0%';
            powerValue.textContent = '0%';
            
            updateStatus(`ƒêang ƒë√°nh... (BƒÉng: 0)`);
            cueInfo.textContent = "Bi ƒëang di chuy·ªÉn...";
        }

        function checkShotEnd() {
            if (!gameState.shotInProgress || balls.some(b => b.moving())) return false;

            gameState.shotInProgress = false;
            let pointScored = false;

            if (gameState.cushionHits >= 3 && gameState.hitRed && gameState.hitYellow) {
                gameState.scores[gameState.currentPlayer - 1]++;
                pointScored = true;
                gameState.replaying = true;
                gameState.replayIndex = 0;
                if (gameState.replay.length === 0) {
                    gameState.replay = balls.map(b => ({ x: b.x, y: b.y }));
                }
            }

            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;

            updateScores();
            updatePlayerTurnDisplay();
            updateStatus(pointScored ? `üéØ ƒêi·ªÉm! L∆∞·ª£t ti·∫øp theo...` : `L∆∞·ª£t k·∫ø ti·∫øp...`);
            cueInfo.textContent = "Nh·∫•p v√†o bi c√°i ƒë·ªÉ k√©o c∆°";

            return true;
        }

        // ==================== C·∫¨P NH·∫¨T GIAO DI·ªÜN ====================
        function updateScores() {
            score1El.textContent = gameState.scores[0];
            score2El.textContent = gameState.scores[1];
        }

        function updatePlayerTurnDisplay() {
            const isPlayer1Turn = gameState.currentPlayer === 1;
            player1Info.classList.toggle('active', isPlayer1Turn);
            player2Info.classList.toggle('active', !isPlayer1Turn);
            status1El.textContent = isPlayer1Turn ? 'üü¢ ƒê·∫øn l∆∞·ª£t b·∫°n!' : 'üîµ Ch·ªù l∆∞·ª£t...';
            status2El.textContent = !isPlayer1Turn ? 'üü¢ ƒê·∫øn l∆∞·ª£t b·∫°n!' : 'üîµ Ch·ªù l∆∞·ª£t...';
        }

        function updateStatus(message) {
            const statusEl = gameState.currentPlayer === 1 ? status1El : status2El;
            if (gameState.shotInProgress) {
                statusEl.textContent = `ƒêang ƒë√°nh... (BƒÉng: ${gameState.cushionHits})`;
            } else {
                statusEl.textContent = message;
            }
        }

        // ==================== X·ª¨ L√ù ƒê·∫¶U V√ÄO ====================
        canvas.addEventListener('mousedown', (e) => {
            if (gameState.shotInProgress || gameState.replaying) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Ki·ªÉm tra click v√†o bi c√°i
            const distToWhite = Math.hypot(mouseX - white.x, mouseY - white.y);
            if (distToWhite <= CONFIG.BALL_RADIUS * 2) {
                gameState.cueActive = true;
                gameState.cueDragging = true;
                gameState.cueStartX = white.x;
                gameState.cueStartY = white.y;
                gameState.cueEndX = mouseX;
                gameState.cueEndY = mouseY;
                updateStatus('K√©o chu·ªôt ƒë·ªÉ l·∫•y l·ª±c, th·∫£ ƒë·ªÉ ƒë√°nh');
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!gameState.cueDragging) return;
            
            const rect = canvas.getBoundingClientRect();
            gameState.cueEndX = e.clientX - rect.left;
            gameState.cueEndY = e.clientY - rect.top;
        });

        canvas.addEventListener('mouseup', (e) => {
            if (gameState.cueDragging) {
                if (gameState.power > 15) { // Ch·ªâ ƒë√°nh n·∫øu c√≥ ƒë·ªß l·ª±c
                    startNewShot();
                } else {
                    gameState.cueActive = false;
                    gameState.cueDragging = false;
                    updateStatus('L·ª±c qu√° y·∫øu! K√©o xa h∆°n.');
                    cueInfo.textContent = "Nh·∫•p v√†o bi c√°i ƒë·ªÉ k√©o c∆°";
                }
            }
        });

        canvas.addEventListener('mouseleave', (e) => {
            if (gameState.cueDragging) {
                gameState.cueActive = false;
                gameState.cueDragging = false;
                updateStatus('Chu·ªôt ra ngo√†i b√†n, th·ª≠ l·∫°i');
                cueInfo.textContent = "Nh·∫•p v√†o bi c√°i ƒë·ªÉ k√©o c∆°";
            }
        });

        // X·ª≠ l√Ω n√∫t √°p ph√™
        spinButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                spinButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameState.spinType = btn.dataset.spin;
                if (gameState.cueActive) {
                    cueInfo.textContent = `L·ª±c: ${Math.round(gameState.power)}% | √Åp ph√™: ${getSpinName(gameState.spinType)} | Th·∫£ chu·ªôt ƒë·ªÉ ƒë√°nh`;
                }
            });
        });

        // ==================== V√íNG L·∫∂P GAME CH√çNH ====================
        function gameLoop() {
            drawBackground();

            if (gameState.replaying) {
                const frame = gameState.replay[gameState.replayIndex];
                if (frame) {
                    balls.forEach((ball, idx) => {
                        ball.x = frame[idx].x;
                        ball.y = frame[idx].y;
                    });
                }
                gameState.replayIndex++;
                if (gameState.replayIndex >= gameState.replay.length) {
                    gameState.replaying = false;
                }
            } else {
                if (gameState.shotInProgress) {
                    gameState.replay.push(balls.map(b => ({ x: b.x, y: b.y })));
                    if (gameState.replay.length > 200) gameState.replay.shift();
                    updatePhysics();
                }
                checkShotEnd();
            }

            balls.forEach(ball => ball.draw());
            drawCue();

            // V·∫Ω overlay ƒëi·ªÉm s·ªë
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 180, 40);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`P1: ${gameState.scores[0]}  |  P2: ${gameState.scores[1]}`, 20, 35);

            requestAnimationFrame(gameLoop);
        }

        // ==================== KH·ªûI ƒê·ªòNG ====================
        // ƒê·∫∑t √°p ph√™ m·∫∑c ƒë·ªãnh
        document.getElementById('spinNone').classList.add('active');
        
        updateScores();
        updatePlayerTurnDisplay();
        updateStatus('Nh·∫•p v√†o bi c√°i ƒë·ªÉ k√©o c∆°');
        gameLoop();
    </script>
</body>
</html>
