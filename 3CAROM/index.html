<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Carom 3 BƒÉng Pro 2P | Bi-a Chuy√™n Nghi·ªáp</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://img.icons8.com/color/48/000000/pool.png" type="image/x-icon">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(to bottom, #0a1f0a, #1a3a1a);
            color: #f0f0f0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .container {
            max-width: 1100px;
            width: 100%;
            text-align: center;
            margin: 0 auto;
            padding: 0 15px;
        }
        header { margin-bottom: 25px; }
        h1 {
            color: #00e5ff;
            text-shadow: 0 0 10px rgba(0, 229, 255, 0.7);
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00e5ff, #ffcc00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle {
            color: #ccc;
            font-size: 1.1rem;
            margin-bottom: 20px;
        }
        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 25px;
        }
        .table-outer {
            position: relative;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.8);
            overflow: hidden;
            border: 8px solid #3b2a1f;
        }
        canvas {
            display: block;
            background: #0e520e;
        }
        .power-ui {
            position: absolute;
            left: -50px;
            top: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 45px;
        }
        .power-label {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            color: #ffcc00;
            font-weight: bold;
            font-size: 1.1rem;
            letter-spacing: 2px;
            margin-bottom: 15px;
        }
        .power-bar-container {
            width: 100%;
            height: 380px;
            background: #222;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: inset 0 0 10px #000;
            position: relative;
            border: 3px solid #444;
        }
        #powerBar {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 0%;
            background: linear-gradient(to top, #0f0 0%, #ff0 50%, #f00 100%);
            border-radius: 9px;
            transition: height 0.05s linear;
        }
        .power-value {
            margin-top: 10px;
            font-size: 1rem;
            color: #00e5ff;
            font-weight: bold;
            min-width: 45px;
            padding: 3px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }
        .player-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 900px;
            margin: 25px auto 15px;
            background: rgba(30, 60, 30, 0.7);
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }
        .player {
            text-align: center;
            flex: 1;
        }
        .player.active {
            background: rgba(0, 100, 100, 0.4);
            border-radius: 10px;
            padding: 10px;
            border: 2px solid #00e5ff;
        }
        .player-name {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .player1 .player-name { color: #00e5ff; }
        .player2 .player-name { color: #ffcc00; }
        .player-score {
            font-size: 3rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 8px currentColor;
        }
        .player-status {
            font-size: 1.2rem;
            margin-top: 8px;
            min-height: 1.8em;
            color: #a0e0a0;
        }
        .controls-instruction {
            background: rgba(40, 40, 40, 0.8);
            padding: 15px 25px;
            border-radius: 15px;
            margin: 15px auto 30px;
            max-width: 900px;
            line-height: 1.8;
            text-align: left;
            font-size: 1.05rem;
        }
        .controls-instruction h3 {
            color: #ffcc00;
            margin-bottom: 10px;
            text-align: center;
        }
        kbd {
            background: #333;
            padding: 4px 10px;
            border-radius: 6px;
            font-family: monospace;
            border: 1px solid #666;
            box-shadow: 0 2px 0 #222;
            color: #ffcc00;
        }
        footer {
            margin-top: 20px;
            color: #aaa;
            font-size: 0.9rem;
            text-align: center;
            padding: 15px;
            border-top: 1px solid #333;
            width: 100%;
        }
        .rule-highlight {
            color: #ff9966;
            font-weight: bold;
        }
        @media (max-width: 1000px) {
            .game-area { flex-direction: column; }
            .power-ui {
                position: static;
                flex-direction: row;
                width: auto;
                height: auto;
                margin-top: 20px;
                justify-content: center;
            }
            .power-label { writing-mode: horizontal-tb; transform: none; margin: 0 15px 0 0; }
            .power-bar-container { width: 40px; height: 200px; }
            .player-info { flex-direction: column; align-items: center; }
            .player { margin-bottom: 15px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üé± CAROM 3 BƒÇNG CHUY√äN NGHI·ªÜP</h1>
            <p class="subtitle">ƒê·∫•u tr√≠ 2 ng∆∞·ªùi ch∆°i - L·ª±c ƒë√°nh v·ª´a ph·∫£i - V·∫≠t l√Ω ch√¢n th·ª±c</p>
        </header>

        <div class="game-area">
            <div class="table-outer">
                <div class="power-ui">
                    <div class="power-label">L·ª∞C ƒê·∫®Y</div>
                    <div class="power-bar-container">
                        <div id="powerBar"></div>
                    </div>
                    <div class="power-value" id="powerValue">0%</div>
                </div>
                <canvas id="gameCanvas" width="900" height="450"></canvas>
            </div>

            <div class="player-info">
                <div class="player player1" id="player1Info">
                    <div class="player-name">NG∆Ø·ªúI CH∆†I 1</div>
                    <div class="player-score" id="score1">0</div>
                    <div class="player-status" id="status1">üîµ ƒêang ch·ªù...</div>
                </div>
                <div class="player player2" id="player2Info">
                    <div class="player-name">NG∆Ø·ªúI CH∆†I 2</div>
                    <div class="player-score" id="score2">0</div>
                    <div class="player-status" id="status2">üü° S·∫µn s√†ng</div>
                </div>
            </div>
        </div>

        <div class="controls-instruction">
            <h3>üéÆ H∆Ø·ªöNG D·∫™N ƒêI·ªÄU KHI·ªÇN & LU·∫¨T CH∆†I</h3>
            <p><strong>C√°ch ch∆°i:</strong> M·ª•c ti√™u l√† d√πng bi c√°i (tr·∫Øng) ch·∫°m <span class="rule-highlight">c·∫£ hai bi m·ª•c ti√™u (ƒë·ªè v√† v√†ng)</span> sau khi bi c√°i ƒë√£ n·∫©y <span class="rule-highlight">√≠t nh·∫•t 3 bƒÉng</span>. M·ªói c√∫ ƒë√°nh h·ª£p l·ªá ƒë∆∞·ª£c <span class="rule-highlight">1 ƒëi·ªÉm</span>.</p>
            <p><strong>ƒêi·ªÅu khi·ªÉn:</strong></p>
            <ul>
                <li><kbd>CLICK CHU·ªòT</kbd> v√†o b√†n ƒë·ªÉ nh·∫Øm h∆∞·ªõng ƒë√°nh (c√¢y c∆° s·∫Ω hi·ªán ra).</li>
                <li>Gi·ªØ ph√≠m <kbd>SPACE</kbd> ƒë·ªÉ tƒÉng l·ª±c ƒë·∫©y (thanh l·ª±c b√™n tr√°i).</li>
                <li>Th·∫£ <kbd>SPACE</kbd> ƒë·ªÉ th·ª±c hi·ªán c√∫ ƒë√°nh.</li>
                <li>Ch·ªù t·∫•t c·∫£ bi d·ª´ng h·∫≥n ƒë·ªÉ k·∫øt th√∫c l∆∞·ª£t v√† t√≠nh ƒëi·ªÉm.</li>
            </ul>
            <p><strong>L∆∞u √Ω:</strong> ƒê·∫£m b·∫£o ch√¢n ch·∫°m s√†n khi ƒë√°nh v√† kh√¥ng ch·∫°m tay/qu·∫ßn √°o v√†o bi. Bi nh·∫£y l√™n bƒÉng r·ªìi r∆°i l·∫°i b√†n v·∫´n h·ª£p l·ªá[citation:1].</p>
        </div>

        <footer>
            <p>¬© 2025 Carom 3 BƒÉng Pro - Phi√™n b·∫£n ƒë∆∞·ª£c t·ªëi ∆∞u cho GitHub Pages | M√¥n th·ªÉ thao tr√≠ tu·ªá v√† k·ªπ thu·∫≠t</p>
        </footer>
    </div>

    <script>
        // ==================== C·∫§U H√åNH GAME ====================
        const CONFIG = {
            BALL_RADIUS: 10,
            FRICTION: 0.990,          // Gi·∫£m ma s√°t m·ªôt ch√∫t ƒë·ªÉ bi lƒÉn xa h∆°n
            MAX_POWER: 120,           // Gi·∫£m l·ª±c t·ªëi ƒëa ƒë·ªÉ l·ª±c v·ª´a ph·∫£i h∆°n
            POWER_INCREMENT: 2.5,     // T·ªëc ƒë·ªô tƒÉng l·ª±c khi gi·ªØ Space
            MIN_MOVING_SPEED: 0.04,
            TIME_SCALE_SLOWMO: 0.3,
            SLOWMO_DURATION: 150
        };

        // ==================== THAM CHI·∫æU DOM ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const powerBar = document.getElementById('powerBar');
        const powerValue = document.getElementById('powerValue');
        const score1El = document.getElementById('score1');
        const score2El = document.getElementById('score2');
        const status1El = document.getElementById('status1');
        const status2El = document.getElementById('status2');
        const player1Info = document.getElementById('player1Info');
        const player2Info = document.getElementById('player2Info');

        // ==================== L·ªöP BI ====================
        class Ball {
            constructor(x, y, color, type) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.color = color;
                this.type = type; // 'cue', 'red', 'yellow'
                this.hitWallX = false;
                this.hitWallY = false;
            }
            moving() {
                return Math.hypot(this.vx, this.vy) > CONFIG.MIN_MOVING_SPEED;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, CONFIG.BALL_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                // Vi·ªÅn cho bi c√°i
                if (this.type === 'cue') {
                    ctx.strokeStyle = '#aaa';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
                // Ch·∫•m ƒëen cho bi m·ª•c ti√™u
                if (this.type === 'red' || this.type === 'yellow') {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, CONFIG.BALL_RADIUS * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = '#000';
                    ctx.fill();
                }
            }
        }

        // T·∫°o bi v·ªõi v·ªã tr√≠ h·ª£p l·ªá[citation:1][citation:4]
        const white = new Ball(150, 225, '#f8f8f8', 'cue');
        const red = new Ball(450, 160, '#ff4d4d', 'red');     // Bi ƒë·ªè ·ªü v·ªã tr√≠ ƒë·∫∑c bi·ªát[citation:1]
        const yellow = new Ball(600, 290, '#ffff66', 'yellow'); // Bi v√†ng ƒë·ªëi ph∆∞∆°ng[citation:4]
        const balls = [white, red, yellow];

        // ==================== TR·∫†NG TH√ÅI GAME ====================
        let gameState = {
            currentPlayer: 1,          // Ng∆∞·ªùi ch∆°i hi·ªán t·∫°i (1 ho·∫∑c 2)
            scores: [0, 0],            // ƒêi·ªÉm s·ªë [P1, P2]
            cushionHits: 0,            // S·ªë bƒÉng bi c√°i ƒë√£ ch·∫°m
            hitRed: false,             // ƒê√£ ch·∫°m bi ƒë·ªè ch∆∞a?
            hitYellow: false,          // ƒê√£ ch·∫°m bi v√†ng ch∆∞a?
            shotInProgress: false,     // ƒêang trong l∆∞·ª£t ƒë√°nh?
            aiming: false,             // ƒêang nh·∫Øm?
            showCue: false,            // Hi·ªÉn th·ªã c√¢y c∆°?
            charging: false,           // ƒêang gi·ªØ Space ƒë·ªÉ l·∫•y l·ª±c?
            power: 0,                  // Gi√° tr·ªã l·ª±c hi·ªán t·∫°i (0-MAX_POWER)
            aimX: 0,                   // T·ªça ƒë·ªô nh·∫Øm X
            aimY: 0,                   // T·ªça ƒë·ªô nh·∫Øm Y
            replay: [],                // L∆∞u tr·ªØ replay
            replaying: false,          // ƒêang ph√°t replay?
            replayIndex: 0,
            timeScale: 1               // T·ªëc ƒë·ªô game (cho hi·ªáu ·ª©ng slow-mo)
        };

        // ==================== V·∫º & HI·ªÜU ·ª®NG ====================
        function drawBackground() {
            // V·∫Ω b√†n
            ctx.fillStyle = '#0e520e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // V·∫Ω logo ·ªü gi·ªØa b√†n (d√πng ·∫£nh htk.jpg n·∫øu c√≥, ho·∫∑c v·∫Ω placeholder)
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const logoRadius = 40;
            ctx.beginPath();
            ctx.arc(centerX, centerY, logoRadius, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(centerX, centerY, 5, centerX, centerY, logoRadius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 100, 0, 0.4)');
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
            ctx.lineWidth = 3;
            ctx.stroke();
            // Ch·ªØ vi·∫øt t·∫Øt
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('HTK', centerX, centerY);

            // V·∫Ω vi·ªÅn b√†n 3D
            ctx.strokeStyle = '#5b2c06';
            ctx.lineWidth = 18;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 6;
            ctx.strokeRect(9, 9, canvas.width - 18, canvas.height - 18);
        }

        function drawCue() {
            if (!gameState.showCue) return;
            const dx = gameState.aimX - white.x;
            const dy = gameState.aimY - white.y;
            const angle = Math.atan2(dy, dx);
            const powerLength = gameState.power * 0.6; // Chi·ªÅu d√†i c∆° t·ªâ l·ªá v·ªõi l·ª±c

            ctx.save();
            ctx.translate(white.x, white.y);
            ctx.rotate(angle);

            // V·∫Ω th√¢n c∆° (m√†u g·ªó)
            ctx.fillStyle = '#deb887';
            ctx.fillRect(-(40 + powerLength), -3, 220, 6);

            // V·∫Ω vi·ªÅn v√† trang tr√≠ c∆°
            ctx.strokeStyle = '#8b5a2b';
            ctx.lineWidth = 1;
            ctx.strokeRect(-(40 + powerLength), -3, 220, 6);
            ctx.fillStyle = '#d2691e';
            ctx.fillRect(-(40 + powerLength), -2, 15, 4); // ƒê·∫ßu c∆°

            ctx.restore();
        }

        // ==================== VA CH·∫†M & V·∫¨T L√ù ====================
        function handleCollision(ballA, ballB) {
            const dx = ballB.x - ballA.x;
            const dy = ballB.y - ballA.y;
            const distance = Math.hypot(dx, dy);
            if (distance >= CONFIG.BALL_RADIUS * 2 || distance === 0) return;

            // Hi·ªáu ·ª©ng slow-mo khi va ch·∫°m m·∫°nh
            if (Math.hypot(ballA.vx, ballA.vy) > 2 || Math.hypot(ballB.vx, ballB.vy) > 2) {
                gameState.timeScale = CONFIG.TIME_SCALE_SLOWMO;
                setTimeout(() => { gameState.timeScale = 1; }, CONFIG.SLOWMO_DURATION);
            }

            // X·ª≠ l√Ω va ch·∫°m ƒë√†n h·ªìi
            const nx = dx / distance;
            const ny = dy / distance;
            const tx = -ny;
            const ty = nx;
            const dpTanA = ballA.vx * tx + ballA.vy * ty;
            const dpTanB = ballB.vx * tx + ballB.vy * ty;
            const dpNormA = ballA.vx * nx + ballA.vy * ny;
            const dpNormB = ballB.vx * nx + ballB.vy * ny;

            const m1 = (dpNormA * 1 + dpNormB * 2) / 3; // Gi·∫£ s·ª≠ bi m·ª•c ti√™u n·∫∑ng h∆°n m·ªôt ch√∫t
            const m2 = (dpNormA * 2 + dpNormB * 1) / 3;

            ballA.vx = tx * dpTanA + nx * m2 * 0.98;
            ballA.vy = ty * dpTanA + ny * m2 * 0.98;
            ballB.vx = tx * dpTanB + nx * m1 * 0.98;
            ballB.vy = ty * dpTanB + ny * m1 * 0.98;

            // ƒê√°nh d·∫•u bi c√°i ƒë√£ ch·∫°m bi m·ª•c ti√™u n√†o
            if (ballA === white || ballB === white) {
                if (ballA === red || ballB === red) gameState.hitRed = true;
                if (ballA === yellow || ballB === yellow) gameState.hitYellow = true;
            }
        }

        function updatePhysics() {
            balls.forEach(ball => {
                // C·∫≠p nh·∫≠t v·ªã tr√≠ v·ªõi timeScale
                ball.x += ball.vx * gameState.timeScale;
                ball.y += ball.vy * gameState.timeScale;
                // Ma s√°t
                ball.vx *= CONFIG.FRICTION;
                ball.vy *= CONFIG.FRICTION;

                // Va ch·∫°m v·ªõi bƒÉng (b√†n size 900x450)
                if (ball.x < CONFIG.BALL_RADIUS && !ball.hitWallX) {
                    ball.vx = Math.abs(ball.vx) * 0.95;
                    ball.hitWallX = true;
                    if (ball === white) gameState.cushionHits++;
                }
                if (ball.x > canvas.width - CONFIG.BALL_RADIUS && !ball.hitWallX) {
                    ball.vx = -Math.abs(ball.vx) * 0.95;
                    ball.hitWallX = true;
                    if (ball === white) gameState.cushionHits++;
                }
                if (ball.y < CONFIG.BALL_RADIUS && !ball.hitWallY) {
                    ball.vy = Math.abs(ball.vy) * 0.95;
                    ball.hitWallY = true;
                    if (ball === white) gameState.cushionHits++;
                }
                if (ball.y > canvas.height - CONFIG.BALL_RADIUS && !ball.hitWallY) {
                    ball.vy = -Math.abs(ball.vy) * 0.95;
                    ball.hitWallY = true;
                    if (ball === white) gameState.cushionHits++;
                }

                // Reset c·ªù va ch·∫°m bƒÉng
                if (ball.x > CONFIG.BALL_RADIUS && ball.x < canvas.width - CONFIG.BALL_RADIUS) ball.hitWallX = false;
                if (ball.y > CONFIG.BALL_RADIUS && ball.y < canvas.height - CONFIG.BALL_RADIUS) ball.hitWallY = false;
            });

            // Ki·ªÉm tra va ch·∫°m gi·ªØa c√°c bi
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    handleCollision(balls[i], balls[j]);
                }
            }
        }

        // ==================== LOGIC GAME ====================
        function startNewShot() {
            const dx = gameState.aimX - white.x;
            const dy = gameState.aimY - white.y;
            const dist = Math.hypot(dx, dy) || 1;
            const powerFactor = gameState.power * 0.30; // H·ªá s·ªë l·ª±c gi·∫£m ƒë·ªÉ l·ª±c v·ª´a ph·∫£i

            white.vx = (dx / dist) * powerFactor;
            white.vy = (dy / dist) * powerFactor;

            // Reset tr·∫°ng th√°i l∆∞·ª£t ƒë√°nh
            gameState.power = 0;
            gameState.charging = false;
            gameState.aiming = false;
            gameState.showCue = false;
            gameState.shotInProgress = true;
            gameState.replay = [];
            gameState.cushionHits = 0;
            gameState.hitRed = false;
            gameState.hitYellow = false;

            // C·∫≠p nh·∫≠t UI
            updateStatus(`ƒêang ƒë√°nh... (BƒÉng: 0)`);
        }

        function checkShotEnd() {
            if (!gameState.shotInProgress || balls.some(b => b.moving())) return false;

            // T·∫§T C·∫¢ BI ƒê√É D·ª™NG -> K·∫øt th√∫c l∆∞·ª£t
            gameState.shotInProgress = false;
            let pointScored = false;

            // Ki·ªÉm tra ƒëi·ªÅu ki·ªán ghi ƒëi·ªÉm Carom 3 BƒÉng
            if (gameState.cushionHits >= 3 && gameState.hitRed && gameState.hitYellow) {
                gameState.scores[gameState.currentPlayer - 1]++;
                pointScored = true;
                // Ph√°t replay n·∫øu ghi ƒëi·ªÉm
                gameState.replaying = true;
                gameState.replayIndex = 0;
                // L∆∞u v·ªã tr√≠ cu·ªëi c√πng v√†o replay ƒë·ªÉ hi·ªÉn th·ªã
                if (gameState.replay.length === 0) {
                    gameState.replay = balls.map(b => ({ x: b.x, y: b.y }));
                }
            }

            // Chuy·ªÉn l∆∞·ª£t
            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;

            // C·∫≠p nh·∫≠t giao di·ªán
            updateScores();
            updatePlayerTurnDisplay();
            updateStatus(pointScored ? `üéØ ƒêi·ªÉm! L∆∞·ª£t ti·∫øp theo...` : `L∆∞·ª£t k·∫ø ti·∫øp...`);

            return true;
        }

        // ==================== C·∫¨P NH·∫¨T GIAO DI·ªÜN ====================
        function updateScores() {
            score1El.textContent = gameState.scores[0];
            score2El.textContent = gameState.scores[1];
        }

        function updatePlayerTurnDisplay() {
            const isPlayer1Turn = gameState.currentPlayer === 1;
            player1Info.classList.toggle('active', isPlayer1Turn);
            player2Info.classList.toggle('active', !isPlayer1Turn);
            status1El.textContent = isPlayer1Turn ? 'üü¢ ƒê·∫øn l∆∞·ª£t b·∫°n!' : 'üîµ Ch·ªù l∆∞·ª£t...';
            status2El.textContent = !isPlayer1Turn ? 'üü¢ ƒê·∫øn l∆∞·ª£t b·∫°n!' : 'üîµ Ch·ªù l∆∞·ª£t...';
        }

        function updateStatus(message) {
            const statusEl = gameState.currentPlayer === 1 ? status1El : status2El;
            if (gameState.shotInProgress) {
                statusEl.textContent = `ƒêang ƒë√°nh... (BƒÉng: ${gameState.cushionHits})`;
            } else {
                statusEl.textContent = message;
            }
        }

        // ==================== V√íNG L·∫∂P GAME CH√çNH ====================
        function gameLoop() {
            drawBackground();

            if (gameState.replaying) {
                // Hi·ªÉn th·ªã replay khi ghi ƒëi·ªÉm
                const frame = gameState.replay[gameState.replayIndex];
                if (frame) {
                    balls.forEach((ball, idx) => {
                        ball.x = frame[idx].x;
                        ball.y = frame[idx].y;
                    });
                }
                gameState.replayIndex++;
                if (gameState.replayIndex >= gameState.replay.length) {
                    gameState.replaying = false;
                }
            } else {
                if (gameState.shotInProgress) {
                    // L∆∞u replay khi ƒëang ƒë√°nh
                    gameState.replay.push(balls.map(b => ({ x: b.x, y: b.y })));
                    if (gameState.replay.length > 200) gameState.replay.shift();
                    updatePhysics();
                }
                checkShotEnd();
            }

            // V·∫Ω bi v√† c∆°
            balls.forEach(ball => ball.draw());
            drawCue();

            // V·∫Ω overlay ƒëi·ªÉm s·ªë
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 180, 40);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`P1: ${gameState.scores[0]}  |  P2: ${gameState.scores[1]}`, 20, 35);

            requestAnimationFrame(gameLoop);
        }

        // ==================== X·ª¨ L√ù ƒê·∫¶U V√ÄO ====================
        canvas.addEventListener('mousedown', (e) => {
            if (gameState.shotInProgress || gameState.replaying) return;
            const rect = canvas.getBoundingClientRect();
            gameState.aimX = e.clientX - rect.left;
            gameState.aimY = e.clientY - rect.top;
            gameState.showCue = gameState.aiming = true;
            updateStatus('Nh·∫Øm & gi·ªØ SPACE ƒë·ªÉ l·∫•y l·ª±c');
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!gameState.aiming) return;
            const rect = canvas.getBoundingClientRect();
            gameState.aimX = e.clientX - rect.left;
            gameState.aimY = e.clientY - rect.top;
        });

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameState.showCue && !gameState.shotInProgress) {
                gameState.charging = true;
                e.preventDefault(); // NgƒÉn cu·ªôn trang
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space' && gameState.charging) {
                if (gameState.power > 10) { // Ch·ªâ ƒë√°nh n·∫øu c√≥ l·ª±c ƒë·ªß
                    startNewShot();
                } else {
                    gameState.charging = false;
                    updateStatus('L·ª±c qu√° y·∫øu! Gi·ªØ SPACE l√¢u h∆°n.');
                }
                e.preventDefault();
            }
        });

        // C·∫≠p nh·∫≠t thanh l·ª±c
        setInterval(() => {
            if (gameState.charging) {
                gameState.power = Math.min(gameState.power + CONFIG.POWER_INCREMENT, CONFIG.MAX_POWER);
                const percent = Math.round((gameState.power / CONFIG.MAX_POWER) * 100);
                powerBar.style.height = percent + '%';
                powerValue.textContent = percent + '%';
                // ƒê·ªïi m√†u ch·ªØ theo l·ª±c
                powerValue.style.color = percent < 50 ? '#0f0' : percent < 80 ? '#ff0' : '#f00';
            }
        }, 30);

        // ==================== KH·ªûI ƒê·ªòNG ====================
        updateScores();
        updatePlayerTurnDisplay();
        updateStatus('Nh·∫•p chu·ªôt ƒë·ªÉ nh·∫Øm, gi·ªØ SPACE ƒë·ªÉ l·∫•y l·ª±c');
        gameLoop();
    </script>
</body>
</html>
