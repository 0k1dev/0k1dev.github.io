<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Carom 3 BƒÉng ‚Äì Pro (Slow Motion)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body{
  margin:0;
  background:#0b0b0b;
  color:#fff;
  font-family:Arial;
  display:flex;
  flex-direction:column;
  align-items:center
}

h1{color:#00e5ff;margin:8px}

.table-wrap{
  position:relative;
  display:inline-block;
}

canvas{
  background:#145214;
  border:18px solid #5b2c06;
  border-radius:12px;
}

.info{
  margin-top:6px;
  font-size:14px;
  color:#ccc
}

/* ===== QR ===== */
.qr-box{
  position:absolute;
  top:10px;
  right:-160px;
  width:150px;
  text-align:center;
}
.qr-box img{
  width:140px;
  background:#fff;
  padding:5px;
  border-radius:10px;
}
.qr-text{
  margin-top:6px;
  font-size:14px;
  color:#ccc;
}
</style>
</head>

<body>
<h1>üé± Carom 3 BƒÉng ‚Äì Pro Training</h1>

<div class="table-wrap">
  <canvas id="c" width="900" height="450"></canvas>

  <div class="qr-box">
    <img id="vietqr">
    <div class="qr-text">·ª¶ng h·ªô t√°c gi·∫£</div>
  </div>
</div>

<div class="info">
  Click bi tr·∫Øng ‚Üí gi·ªØ SPACE l·∫•y l·ª±c | A/D xo√°y | S = kh√¥ng xo√°y
</div>

<script>
/* ===== QR ===== */
document.getElementById("vietqr").src =
  "https://img.vietqr.io/image/ACB-43146717-compact2.png?addInfo=Donate+Carom+3+Bang";

/* ===== CANVAS ===== */
const c=document.getElementById("c");
const ctx=c.getContext("2d");

/* ===== CONST ===== */
const R=10;
const FRICTION=0.992;
const MAX_POWER=160;

/* ===== SLOW MOTION ===== */
let TIME_SCALE = 1;
let slowTimer = 0;

function triggerSlow(){
  TIME_SCALE = 0.25;      // t·ªëc ƒë·ªô slow
  slowTimer = 35;        // th·ªùi gian slow (~0.6s)
}

/* ===== BALL ===== */
class Ball{
  constructor(x,y,color){
    this.x=x;this.y=y;
    this.vx=0;this.vy=0;
    this.color=color;
  }
}

let white=new Ball(150,225,"#fff");
let red=new Ball(450,160,"red");
let yellow=new Ball(600,290,"yellow");
const balls=[white,red,yellow];

/* ===== STATE ===== */
let showCue=false;
let aiming=false;
let aimX=0, aimY=0;
let charging=false;
let power=0;
let spin=0;

/* ===== SCORE ===== */
let score=0;
let cushionCount=0;
let hitRed=false;
let hitYellow=false;

/* ===== DRAW ===== */
function drawDots(){
  ctx.fillStyle="#cfa";
  const d=c.width/8;
  for(let i=1;i<8;i++){
    ctx.beginPath();ctx.arc(i*d,8,3,0,6.28);ctx.fill();
    ctx.beginPath();ctx.arc(i*d,c.height-8,3,0,6.28);ctx.fill();
  }
}

function drawBall(b){
  ctx.beginPath();
  ctx.arc(b.x,b.y,R,0,6.28);
  ctx.fillStyle=b.color;
  ctx.fill();
}

/* ===== PREDICT ===== */
function drawPredict(){
  if(!showCue) return;

  let x=white.x,y=white.y;
  let dx=aimX-white.x, dy=aimY-white.y;
  let len=Math.hypot(dx,dy)||1;
  dx/=len; dy/=len;

  ctx.setLineDash([6,6]);
  ctx.strokeStyle="rgba(255,255,255,.6)";
  ctx.beginPath();
  ctx.moveTo(x,y);

  for(let i=0;i<3;i++){
    let tx=dx>0?(c.width-R-x)/dx:(R-x)/dx;
    let ty=dy>0?(c.height-R-y)/dy:(R-y)/dy;
    let t=Math.min(tx,ty);
    x+=dx*t; y+=dy*t;
    ctx.lineTo(x,y);
    if(tx<ty) dx*=-1; else dy*=-1;
  }
  ctx.stroke();
  ctx.setLineDash([]);
}

/* ===== CUE ===== */
function drawCue(){
  if(!showCue) return;

  let dx=aimX-white.x;
  let dy=aimY-white.y;
  let ang=Math.atan2(dy,dx);

  const GAP=20;
  const PULL=power*0.8;
  const LEN=220;

  ctx.save();
  ctx.translate(white.x,white.y);
  ctx.rotate(ang);
  ctx.fillStyle="#deb887";
  ctx.fillRect(-(GAP+PULL+LEN),-2,LEN,4);
  ctx.restore();
}

/* ===== COLLISION ===== */
function collide(a,b){
  const dx=b.x-a.x, dy=b.y-a.y;
  const dist=Math.hypot(dx,dy);
  if(dist>=2*R||dist===0) return;

  triggerSlow();

  const nx=dx/dist, ny=dy/dist;
  const tx=-ny, ty=nx;

  const dpTanA=a.vx*tx+a.vy*ty;
  const dpTanB=b.vx*tx+b.vy*ty;
  const dpNormA=a.vx*nx+a.vy*ny;
  const dpNormB=b.vx*nx+b.vy*ny;

  const REST=0.98;

  a.vx=tx*dpTanA+nx*dpNormB*REST;
  a.vy=ty*dpTanA+ny*dpNormB*REST;
  b.vx=tx*dpTanB+nx*dpNormA*REST;
  b.vy=ty*dpTanB+ny*dpNormA*REST;

  const overlap=2*R-dist;
  a.x-=nx*overlap/2; a.y-=ny*overlap/2;
  b.x+=nx*overlap/2; b.y+=ny*overlap/2;

  if(a===white||b===white){
    if(a===red||b===red) hitRed=true;
    if(a===yellow||b===yellow) hitYellow=true;
  }
}

/* ===== UPDATE ===== */
function update(){
  ctx.clearRect(0,0,c.width,c.height);
  drawDots();

  balls.forEach(b=>{
    b.x += b.vx * TIME_SCALE;
    b.y += b.vy * TIME_SCALE;

    b.vx *= Math.pow(FRICTION, TIME_SCALE);
    b.vy *= Math.pow(FRICTION, TIME_SCALE);

    if(Math.hypot(b.vx,b.vy)<0.02) b.vx=b.vy=0;

    if(b.x<R){b.x=R;b.vx=Math.abs(b.vx); if(b===white){cushionCount++;triggerSlow();}}
    if(b.x>c.width-R){b.x=c.width-R;b.vx=-Math.abs(b.vx); if(b===white){cushionCount++;triggerSlow();}}
    if(b.y<R){b.y=R;b.vy=Math.abs(b.vy); if(b===white){cushionCount++;triggerSlow();}}
    if(b.y>c.height-R){b.y=c.height-R;b.vy=-Math.abs(b.vy); if(b===white){cushionCount++;triggerSlow();}}
  });

  collide(white,red);
  collide(white,yellow);
  collide(red,yellow);

  balls.forEach(drawBall);
  drawPredict();
  drawCue();

  ctx.fillStyle="#fff";
  ctx.font="18px Arial";
  ctx.fillText("SCORE: "+score,20,30);

  if(cushionCount>=3 && hitRed && hitYellow && white.vx===0 && white.vy===0){
    score++;
    cushionCount=0;
    hitRed=hitYellow=false;
  }

  if(slowTimer>0){
    slowTimer--;
    if(slowTimer===0) TIME_SCALE=1;
  }

  requestAnimationFrame(update);
}

/* ===== INPUT ===== */
c.addEventListener("mousedown",e=>{
  if(white.vx||white.vy) return;
  const r=c.getBoundingClientRect();
  const x=e.clientX-r.left, y=e.clientY-r.top;
  if(Math.hypot(x-white.x,y-white.y)<R+5){
    showCue=aiming=true;
    aimX=x; aimY=y;
  }
});

c.addEventListener("mousemove",e=>{
  if(!aiming) return;
  const r=c.getBoundingClientRect();
  aimX=e.clientX-r.left;
  aimY=e.clientY-r.top;
});

window.addEventListener("keydown",e=>{
  if(e.code==="Space"&&showCue) charging=true;
  if(e.key==="a") spin=-1;
  if(e.key==="d") spin=1;
  if(e.key==="s") spin=0;
});

window.addEventListener("keyup",e=>{
  if(e.code==="Space"&&showCue){
    let dx=aimX-white.x, dy=aimY-white.y;
    let len=Math.hypot(dx,dy)||1;
    let force=power*0.38;
    white.vx=(dx/len)*force;
    white.vy=(dy/len)*force;
    power=0; charging=false; showCue=false; aiming=false;
  }
});

setInterval(()=>{
  if(charging) power=Math.min(power+4,MAX_POWER);
},30);

update();
</script>
</body>
</html>
