<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Block Puzzle 10x10 - HuyTKing</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ˜˜</text></svg>">
<style>
    body {
        background: #1d2333;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: Arial;
        color: #fff;
    }
    .game {
        display: flex;
        gap: 20px;
    }
    #board {
        width: 400px;
        height: 400px;
        background: #0a1020;
        display: grid;
        grid-template-columns: repeat(10, 1fr);
        grid-template-rows: repeat(10, 1fr);
        gap: 2px;
        padding: 5px;
        border-radius: 10px;
    }
    .cell {
        background: #141a2e;
        border-radius: 4px;
    }
    #pieces {
        width: 200px;
        display: flex;
        flex-direction: column;
        gap: 20px;
    }
    .piece {
        display: inline-grid;
        gap: 3px;
        padding: 10px;
        background: #0b1426;
        border-radius: 10px;
        cursor: grab;
        width: fit-content;
    }
    .block {
        width: 20px;
        height: 20px;
        background: #4fc3f7;
        border-radius: 4px;
    }
</style>
</head>
<body>

<div class="game">
    <div id="board"></div>
    <div id="pieces"></div>
</div>

<script>
const boardSize = 10;
const cellSize = 40;
const board = [];
const boardDiv = document.getElementById("board");
const piecesDiv = document.getElementById("pieces");

let draggingPiece = null;
let draggingShape = null;
let previewCells = [];

const blockShapes = [
    [[1]],
    [[1,1]],
    [[1],[1]],
    [[1,1,1]],
    [[1],[1],[1]],
    [[1,1],[1,1]],
    [[1,1,1],[0,1,0]]
];

// Táº¡o board
function initBoard() {
    for (let r = 0; r < boardSize; r++) {
        board[r] = [];
        for (let c = 0; c < boardSize; c++) {
            board[r][c] = 0;
            const cell = document.createElement("div");
            cell.className = "cell";
            cell.dataset.row = r;
            cell.dataset.col = c;
            boardDiv.appendChild(cell);
        }
    }
}
initBoard();

function renderBoard() {
    boardDiv.childNodes.forEach(cell => {
        let r = cell.dataset.row;
        let c = cell.dataset.col;
        cell.style.background = board[r][c] ? "#4fc3f7" : "#141a2e";
    });
}

// Táº¡o khá»‘i
function generatePieces() {
    piecesDiv.innerHTML = "";
    for (let i = 0; i < 3; i++) {
        let shape = blockShapes[Math.floor(Math.random()*blockShapes.length)];
        createPiece(shape);
    }
}

function createPiece(shape) {
    const piece = document.createElement("div");
    piece.className = "piece";
    piece.style.position = "relative";
    piece.style.gridTemplateColumns = `repeat(${shape[0].length}, 20px)`;

    shape.forEach(row => {
        row.forEach(val => {
            const block = document.createElement("div");
            block.className = "block";
            block.style.visibility = val ? "visible" : "hidden";
            piece.appendChild(block);
        });
    });

    piece.addEventListener("mousedown", e => startDrag(e, shape, piece));
    piecesDiv.appendChild(piece);
}

// Báº¯t Ä‘áº§u kÃ©o
function startDrag(e, shape, piece) {
    draggingPiece = piece.cloneNode(true);
    draggingShape = shape;

    draggingPiece.style.position = "fixed";
    draggingPiece.style.pointerEvents = "none";
    draggingPiece.style.opacity = "0.8";
    draggingPiece.style.transform = "scale(1.4)";
    document.body.appendChild(draggingPiece);

    moveDrag(e);

    document.addEventListener("mousemove", moveDrag);
    document.addEventListener("mouseup", stopDrag);
}

function moveDrag(e) {
    if (!draggingPiece) return;

    draggingPiece.style.left = e.pageX - 20 + "px";
    draggingPiece.style.top = e.pageY - 20 + "px";

    showPreview(e);
}

// Preview vá»‹ trÃ­ khá»‘i
function showPreview(e) {
    clearPreview();

    const rect = boardDiv.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;

    if (x < 0 || y < 0 || x > rect.width || y > rect.height) return;

    let col = Math.floor(x / cellSize);
    let row = Math.floor(y / cellSize);

    if (!canPlace(draggingShape, row, col)) return;

    // highlight
    draggingShape.forEach((r, i) => {
        r.forEach((v, j) => {
            if (v === 1) {
                let cellIndex = (row + i) * boardSize + (col + j);
                if (boardDiv.childNodes[cellIndex]) {
                    boardDiv.childNodes[cellIndex].style.background = "#77e0ff";
                    previewCells.push(boardDiv.childNodes[cellIndex]);
                }
            }
        });
    });
}

function clearPreview() {
    previewCells.forEach(c => {
        let r = c.dataset.row;
        let col = c.dataset.col;
        c.style.background = board[r][col] ? "#4fc3f7" : "#141a2e";
    });
    previewCells = [];
}

// Tháº£ chuá»™t
function stopDrag(e) {
    document.removeEventListener("mousemove", moveDrag);
    document.removeEventListener("mouseup", stopDrag);

    if (draggingPiece) draggingPiece.remove();

    const rect = boardDiv.getBoundingClientRect();
    let x = e.clientX - rect.left;
    let y = e.clientY - rect.top;

    let col = Math.floor(x / cellSize);
    let row = Math.floor(y / cellSize);

    if (canPlace(draggingShape, row, col)) {
        place(draggingShape, row, col);
        clearPreview();
        piecesDiv.querySelector(".piece")?.remove();
        if (piecesDiv.children.length === 0) generatePieces();
    }

    draggingPiece = null;
    draggingShape = null;
}

function canPlace(shape, row, col) {
    for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[0].length; c++) {
            if (shape[r][c]) {
                if (row+r >= boardSize || col+c >= boardSize) return false;
                if (board[row+r][col+c] !== 0) return false;
            }
        }
    }
    return true;
}

function place(shape, row, col) {
    for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[0].length; c++) {
            if (shape[r][c]) board[row+r][col+c] = 1;
        }
    }
    clearLines();
    renderBoard();
}

function clearLines() {
    for (let r = 0; r < boardSize; r++) {
        if (board[r].every(v => v === 1)) board[r].fill(0);
    }
    for (let c = 0; c < boardSize; c++) {
        let full = true;
        for (let r = 0; r < boardSize; r++) if (!board[r][c]) full = false;
        if (full) for (let r = 0; r < boardSize; r++) board[r][c] = 0;
    }
}

generatePieces();
renderBoard();
</script>


</body>
</html>
